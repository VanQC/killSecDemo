# Go-SecKill
基于Go语言的秒杀商品系列


## 单机模式

> 测试前提：库存100，抢购人数50

1. 不加锁：api/v1/without-lock?gid=2 （少卖）

这个没啥好说的，不加锁在并发情况下肯定会出错。

2. 加锁(sync包中的Mutex类型的互斥锁)：api/v1/with-lock?gid=2 （不超卖也不少卖）

这个锁是加在代码层面，每个请求都挨个处理。

3. 加锁(数据库悲观锁，读限定)：api/v1/with-pcc-read?gid=2 （少卖）

这里是加数据库读锁，那么其他人也可以读，假设并发10个人都读到库存是90，那么他们更新数据库的时候都是更新成89。
所以就会出现【实际promotion数据表中kill的数量】<【success数据表成功的数量】

4. 加锁(数据库悲观锁，更新限定）：api/v1/with-pcc-update?gid=2 （不超卖也不少卖）

这里与加Mutex类型的互斥锁是相似的。但是这里锁是由数据库本身实现的。
它采用的直接去扣库存的方式，不经过读操作，而是直接在数据库的库存基础上-1，写成功后就认为抢购成功。
`UPDATE promotion_sec_kills SET ps_count = ps_count-1 WHERE ps_count>0 AND goods_id = ?`
但是这种情况属于直接访问数据库，高并发下数据库会瘫痪。（其实这几种单机方式都是直接访问的数据库）

5. 加锁(数据库乐观锁)：api/v1/with-occ?gid=2 （少卖）

此种情况下，success 订单数量和仓库中减少的物品数量一致。但是售出数量不足50，只有个位数。
读库存的时候不加锁，但是会读到库存的版本号；当读取到库存有剩余时，回去数据库进行写库存-1，但是写的时候要求和读的时候版本号一致。
因为在并发情况下，会有其他协程优先去写数据库，此时会发现版本号不一致，写数据库失败，也就不会创建 success 订单。

6. 使用 channel 限制：api/v1/with-channel?gid=2 （不超卖也不少卖）

此种情况下，success 订单数量和仓库中减少的物品数量一致。售出数量也是50，不超卖也不少卖。


## 分布式模式


### 基于Redisson的Redis分布式锁，正常

> api/v2/with-redission?gid=2

这里仅仅使用了Redis分布式提供的锁功能，秒杀数据处理还是直接访问数据库来完成

### 基于缓存的ETCD分布式锁，正常

> api/v2/with-etcd?gid=2

注意这里也要用ETCD分布式锁把整个事务提交都包住。这里只用了ETCD的分布式锁功能，
秒杀数据处理也是直接访问数据库来完成

### Redis的List队列，正常

> api/v2/with-redis-list?gid=2

这里利用Redis分布式队列的方式是，在秒杀活动初始化阶段时有多少库存就在Redis的List中初始化多少个商品元素。
然后每有一个用户进行秒杀，就从List队列中取出一个商品元素分配给该用户。
同时将该用户信息存入到Redis的Set类型中，防止用户多次秒杀的情况。
在秒杀结束之后，在Redis中数据写入到数据库中进行保存。

### 


### 其他实现方式

1. Redis原子递减

这里先将秒杀商品的库存数量，写入到redis中，利用redis的incr来实现原子递减。
假如有100件商品，这里相当于准备好了100个钥匙，有人没有抢到钥匙，就返回库存不够，有人抢到了钥匙，
就进行下一步处理，先将秒杀订单的信息写入到redis中，等空闲下来后在写入到数据库中。
这里其实与case3差不多，不过是吧List换成incr来实现原子递减。

2. 基于Redis的任务队列，订阅监听

(是将在前端进行秒杀的用户的信息传入到通道中，等待被消费。后端订阅监听这个通道，有秒杀用户信息传过来就进行消费处理，再将处理数据写入到数据库。)

3. 基于MQ消息队列的分布式锁

